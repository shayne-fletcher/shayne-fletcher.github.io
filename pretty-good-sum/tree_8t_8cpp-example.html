<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Pretty Good Sum Type: tree.t.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pretty Good Sum Type
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">tree.t.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Dead simple, purely functional binary search tree</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gtest/gtest.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;sum_type.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacepgs.html">pgs</a>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">namespace </span>detail {</div>
<div class="line">    <span class="comment">//(&#39;a, &#39;b) tree = </span></div>
<div class="line">    <span class="comment">//  | Empty </span></div>
<div class="line">    <span class="comment">//  | Node of (&#39;a, &#39;b) * (&#39;a, &#39;b) tree * (&#39;a,&#39;b) tree</span></div>
<div class="line">    <span class="keyword">struct </span>empty_t {}; <span class="comment">//Case 1</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> V&gt; <span class="keyword">struct </span>node_t; <span class="comment">//Case 2</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">//Since `node_t&lt;K, V&gt;` values contain `tree&lt;K, V&gt;` values,</span></div>
<div class="line">    <span class="comment">//`node_&lt;K, V&gt;` is a recursive type</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    <span class="keyword">using</span> tree = <a name="_a0"></a><a class="code" href="classpgs_1_1sum__type.html">sum_type &lt;empty_t, recursive_wrapper&lt;node_t&lt;K, V&gt;</a>&gt;&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//A definition for `tree&lt;K, V&gt;` being available, now we can &quot;fill</span></div>
<div class="line">    <span class="comment">//in&quot; the definition of `node_t&lt;K, V&gt;`</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    <span class="keyword">struct </span>node_t {</div>
<div class="line">      <span class="keyword">using</span> tree_type = tree&lt;K, V&gt;;</div>
<div class="line">      <span class="keyword">using</span> value_type = <a name="_a1"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a>; </div>
<div class="line"></div>
<div class="line">      <span class="comment">//Construct a `node_t` from `data`, a `left` and a `right`</span></div>
<div class="line">      <span class="comment">//sub-tree</span></div>
<div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">class</span> P, <span class="keyword">class</span> U, <span class="keyword">class</span> V&gt;</div>
<div class="line">      node_t (P&amp;&amp; data, U&amp;&amp; left_child, V&amp;&amp; right_child) </div>
<div class="line">        : data (std::forward&lt;P&gt;(data))</div>
<div class="line">        , left_child (std::forward&lt;U&gt; (left_child))</div>
<div class="line">        , right_child (std::forward&lt;V&gt; (right_child))</div>
<div class="line">      {}</div>
<div class="line"></div>
<div class="line">      <span class="comment">//A node consists of:</span></div>
<div class="line">      value_type data; <span class="comment">//data</span></div>
<div class="line">      tree_type left_child; <span class="comment">//a left sub-tree and</span></div>
<div class="line">      tree_type right_child;<span class="comment">//a right sub-tree</span></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> empty (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;<span class="keywordtype">bool</span>&gt;(</div>
<div class="line">       [](empty_t) { <span class="keywordflow">return</span> <span class="keyword">true</span>; },</div>
<div class="line">       [](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp;) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line">       );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V, <span class="keyword">class</span> AccT, <span class="keyword">class</span> F&gt;</div>
<div class="line">    AccT fold (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t, AccT <span class="keyword">const</span>&amp; z, F f) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;AccT&gt;(</div>
<div class="line">       [&amp;z](empty_t <span class="keyword">const</span>&amp;) -&gt; AccT { <span class="keywordflow">return</span> z; },</div>
<div class="line">       [=, &amp;z](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp; n) -&gt; AccT {</div>
<div class="line">         <span class="keyword">auto</span> <span class="keyword">const</span>&amp; b = n.data;</div>
<div class="line">         <span class="keyword">auto</span> <span class="keyword">const</span>&amp; l = n.left_child;</div>
<div class="line">         <span class="keyword">auto</span> <span class="keyword">const</span>&amp; r = n.right_child;</div>
<div class="line">         <span class="keywordflow">return</span> fold(r, f (fold (l, z, f), b), f);</div>
<div class="line">       }</div>
<div class="line">     );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V, <span class="keyword">class</span> P&gt;</div>
<div class="line">    tree&lt;K, V&gt; insert (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t, P&amp;&amp; p) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;tree&lt;K, V&gt;&gt; (</div>
<div class="line">         [&amp;p](empty_t) { </div>
<div class="line">         <span class="keywordflow">return</span> tree&lt;K, V&gt;{</div>
<div class="line">            <a name="_a2"></a><a class="code" href="structpgs_1_1constructor.html">constructor&lt;node_t&lt;K, V&gt;</a>&gt;{}</div>
<div class="line">          , std::forward&lt;P&gt;(p)</div>
<div class="line">          , tree&lt;K, V&gt; {<a class="code" href="structpgs_1_1constructor.html">constructor&lt;empty_t&gt;</a>{}}</div>
<div class="line">          , tree&lt;K, V&gt; {<a class="code" href="structpgs_1_1constructor.html">constructor&lt;empty_t&gt;</a>{}}</div>
<div class="line">          };</div>
<div class="line">        },</div>
<div class="line">       [&amp;p](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp; m) {</div>
<div class="line">          K <span class="keyword">const</span>&amp; k = p.first;</div>
<div class="line">          V <span class="keyword">const</span>&amp; v = p.second;</div>
<div class="line">          K <span class="keyword">const</span>&amp; a = m.data.first;</div>
<div class="line">          tree&lt;K, V&gt; <span class="keyword">const</span>&amp; l = m.left_child;</div>
<div class="line">          tree&lt;K, V&gt; <span class="keyword">const</span>&amp; r = m.right_child;</div>
<div class="line">          <span class="keywordflow">if</span> (k == a)</div>
<div class="line">            <span class="keywordflow">return</span> tree&lt;K, V&gt;{ </div>
<div class="line">                <a class="code" href="structpgs_1_1constructor.html">constructor&lt;node_t&lt;K, V&gt;</a>&gt;{}</div>
<div class="line">                , std::forward&lt;P&gt; (p), l, r};</div>
<div class="line">          <span class="keywordflow">if</span> (k &lt; a) {</div>
<div class="line">            <span class="keywordflow">return</span> tree&lt;K, V&gt;{ </div>
<div class="line">                <a class="code" href="structpgs_1_1constructor.html">constructor&lt;node_t&lt;K, V&gt;</a>&gt;{}</div>
<div class="line">                , m.data, insert (l, p), r};</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> tree&lt;K, V&gt;{ </div>
<div class="line">              <a class="code" href="structpgs_1_1constructor.html">constructor&lt;node_t&lt;K, V&gt;</a>&gt;{}</div>
<div class="line">              , m.data, l, insert (r, p)};</div>
<div class="line">        }</div>
<div class="line">      );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> contains (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t, K <span class="keyword">const</span>&amp; k) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;<span class="keywordtype">bool</span>&gt;(</div>
<div class="line">        [](empty_t) { <span class="keywordflow">return</span> <span class="keyword">false</span>; },</div>
<div class="line">        [&amp;k](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp; n) {</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; a = n.data.first;</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; l = n.left_child;</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; r = n.right_child;</div>
<div class="line">          <span class="keywordflow">if</span> (k == a) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">          <span class="keywordflow">if</span> (k &lt; a) <span class="keywordflow">return</span> contains (l, k);</div>
<div class="line">          <span class="keywordflow">return</span> contains (r, k);</div>
<div class="line">        }</div>
<div class="line">      );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    V <span class="keyword">const</span>&amp; lookup (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t, K <span class="keyword">const</span>&amp; k) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;V <span class="keyword">const</span>&amp;&gt;(</div>
<div class="line">        [](empty_t <span class="keyword">const</span>&amp;) -&gt; V <span class="keyword">const</span>&amp; { </div>
<div class="line">          <span class="keywordflow">throw</span> <a name="_a3"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a>{<span class="stringliteral">&quot;lookup&quot;</span>}; </div>
<div class="line">        },</div>
<div class="line">        [&amp;k](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp; n) -&gt; V <span class="keyword">const</span>&amp; { </div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; a = n.data.first;</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; l = n.left_child;</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; r = n.right_child;</div>
<div class="line">          <span class="keywordflow">if</span> (k == a) <span class="keywordflow">return</span> n.data.second;</div>
<div class="line">          <span class="keywordflow">if</span> (k &lt; a) <span class="keywordflow">return</span> lookup (l, k);</div>
<div class="line">          <span class="keywordflow">return</span> lookup (r, k); </div>
<div class="line">        }</div>
<div class="line">      );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V, <span class="keyword">class</span> P&gt;</div>
<div class="line">    <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;tree&lt;K, V&gt;</a>, tree&lt;K, V&gt;&gt; <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/partition.html">partition</a> (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t, P <span class="keyword">const</span>&amp; p) {</div>
<div class="line">      <span class="keyword">auto</span> f = [&amp;p](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; acc, <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; b) {</div>
<div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span>&amp; l = acc.first;</div>
<div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span>&amp; r = acc.second;</div>
<div class="line">        <span class="keywordflow">if</span> (p (b))</div>
<div class="line">          <span class="keywordflow">return</span> <a name="a4"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (insert (l, b), r);</div>
<div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (l, insert (r, b));</div>
<div class="line">      };</div>
<div class="line">      tree&lt;K, V&gt; <span class="keyword">const</span> empty{<a class="code" href="structpgs_1_1constructor.html">constructor&lt;empty_t&gt;</a>{}};</div>
<div class="line">      <span class="keywordflow">return</span> fold (t, <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (empty, empty), f);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; min_binding (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp;&gt;(</div>
<div class="line">        [](empty_t) -&gt; <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; {  </div>
<div class="line">         <span class="keywordflow">throw</span> <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a>{<span class="stringliteral">&quot;min_binding&quot;</span>};</div>
<div class="line">       },</div>
<div class="line">       [](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp; n) -&gt; <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; {  </div>
<div class="line">         <span class="keyword">auto</span> <span class="keyword">const</span>&amp; l = n.left_child;</div>
<div class="line">         <span class="keywordflow">if</span> (empty (l)) <span class="keywordflow">return</span> n.data;</div>
<div class="line">         <span class="keywordflow">return</span> min_binding (l);</div>
<div class="line">       }</div>
<div class="line">     );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">    <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; max_binding (tree&lt;K, V&gt; <span class="keyword">const</span>&amp; t) {</div>
<div class="line">      <span class="keywordflow">return</span> t.match&lt;<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp;&gt;(</div>
<div class="line">        [](empty_t) -&gt; <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; {  </div>
<div class="line">         <span class="keywordflow">throw</span> <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a>{<span class="stringliteral">&quot;max_binding&quot;</span>};</div>
<div class="line">       },</div>
<div class="line">       [](node_t&lt;K, V&gt; <span class="keyword">const</span>&amp; n) -&gt; <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;K, V&gt;</a> <span class="keyword">const</span>&amp; {  </div>
<div class="line">         <span class="keyword">auto</span> <span class="keyword">const</span>&amp; r = n.right_child;</div>
<div class="line">         <span class="keywordflow">if</span> (empty (r)) <span class="keywordflow">return</span> n.data;</div>
<div class="line">         <span class="keywordflow">return</span> max_binding (r);</div>
<div class="line">       }</div>
<div class="line">     );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> empty_type = empty_t;</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">      <span class="keyword">using</span> node_type =node_t&lt;K, V&gt;;</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">      <span class="keyword">using</span> value_type = <span class="keyword">typename</span> node_type&lt;K, V&gt;::value_type;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">      <span class="keyword">using</span> tree_type = <span class="keyword">typename</span> node_type&lt;K, V&gt;::tree_type;</div>
<div class="line"></div>
<div class="line">  }<span class="comment">//namespace detail</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">//Dead simple binary search tree - no attempt at balancing</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">  <span class="keyword">class </span>binary_search_tree {</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">//These abbreviations will become essential in your efforts to</span></div>
<div class="line">    <span class="comment">//retain some sanity in what follows</span></div>
<div class="line">    <span class="keyword">using</span> empty_type = detail::empty_t;</div>
<div class="line">    <span class="keyword">using</span> node_type = detail::node_type&lt;K, V&gt;;</div>
<div class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> node_type::value_type;</div>
<div class="line">    <span class="keyword">using</span> tree_type = <span class="keyword">typename</span> node_type::tree_type;</div>
<div class="line">    <span class="keyword">using</span> self_type = binary_search_tree&lt;K, V&gt;;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    tree_type impl_; <span class="comment">//the root of the tree</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">//Extension constructor for internal use</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    binary_search_tree (T&amp;&amp; n) : impl_ (std::forward&lt;T&gt; (n))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">//Default construction results in the empty tree</span></div>
<div class="line">    binary_search_tree() : impl_{<a class="code" href="structpgs_1_1constructor.html">constructor&lt;empty_type&gt;</a>{}} </div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Test for emptiness</span></div>
<div class="line">    <span class="keywordtype">bool</span> empty () {</div>
<div class="line">      <span class="keywordflow">return</span> detail::empty (impl_);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Apply &#39;f&#39; to each binding in the tree</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> AccT, <span class="keyword">class</span> F&gt;</div>
<div class="line">    AccT fold (AccT <span class="keyword">const</span>&amp; z, F f)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> detail::fold (impl_, z, f);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Compute a new tree with the same bindings as self but also</span></div>
<div class="line">    <span class="comment">//containing the binding `(k, v)`. If `k` was already bound in</span></div>
<div class="line">    <span class="comment">//self, that binding is replaced by `(k, v)`</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;</div>
<div class="line">    self_type insert (P&amp;&amp; p)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> self_type { detail::insert (impl_, std::forward&lt;P&gt;(p))};</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Compute a new tree with same bindings as self but without a</span></div>
<div class="line">    <span class="comment">//binding `k`</span></div>
<div class="line">    self_type <span class="keyword">remove</span> (K <span class="keyword">const</span>&amp; k) <span class="keyword">const</span> {</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;fold (self_type {},</div>
<div class="line">        [&amp;k](self_type <span class="keyword">const</span>&amp; acc, value_type <span class="keyword">const</span>&amp; p) {</div>
<div class="line">          <span class="keywordflow">return</span> k == p.first ? acc : acc.insert (p);</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Compute the number of bindings in the tree</span></div>
<div class="line">    <a name="_a5"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> size ()<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;fold (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a>{0}</div>
<div class="line">          , [](<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> acc, <span class="keyword">auto</span> <span class="keyword">const</span>&amp;) { <span class="keywordflow">return</span> ++acc; });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//True if `k` is bound</span></div>
<div class="line">    <span class="keywordtype">bool</span> contains (K <span class="keyword">const</span>&amp; k)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> detail::contains (impl_, k);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Get the value bound to `k` in the tree. Raise a</span></div>
<div class="line">    <span class="comment">//`std::runtime_error` if there is no binding for `k`</span></div>
<div class="line">    V <span class="keyword">const</span>&amp; lookup (K <span class="keyword">const</span>&amp; k)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> detail::lookup (impl_, k);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Extract the bindings in the tree. They&#39;ll come back sorted</span></div>
<div class="line">    <span class="comment">//lexicographicaly on keys</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ItT&gt;</div>
<div class="line">    ItT bindings (ItT dst)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;fold (dst, [](<span class="keyword">auto</span> dst, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) { </div>
<div class="line">          <span class="keywordflow">return</span> *dst++ = n; });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Check if all the bindings in the tree satisfy the predicate `p`</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> for_all (P <span class="keyword">const</span>&amp; p)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;fold (<span class="keyword">true</span>, [&amp;p](<span class="keyword">auto</span> acc, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) { </div>
<div class="line">          <span class="keywordflow">return</span> acc &amp;&amp; p (n); });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//True if at least one binding satisfies the predicate `p`</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> exists (P <span class="keyword">const</span>&amp; p)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> fold (<span class="keyword">false</span>, [&amp;p](<span class="keyword">auto</span> acc, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) {</div>
<div class="line">          <span class="keywordflow">return</span> acc || p (n); });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Compute a tree all the bindings that satisfy the predicate &#39;p&#39;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;</div>
<div class="line">    self_type filter (P <span class="keyword">const</span>&amp; p)<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keyword">auto</span> f = [&amp;p](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; acc, value_type <span class="keyword">const</span>&amp; b) {</div>
<div class="line">        <span class="keywordflow">if</span> (p (b))</div>
<div class="line">          <span class="keywordflow">return</span> acc.insert (b);</div>
<div class="line">        <span class="keywordflow">return</span> acc;</div>
<div class="line">      };</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;fold (self_type{}, f);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Compute a pair of maps `(l, r)` where `l` contains all the</span></div>
<div class="line">    <span class="comment">//bindings that satisfy the predicate `p` and `r` is all the</span></div>
<div class="line">    <span class="comment">//bindings that dont&#39;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt;</div>
<div class="line">    <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;self_type, self_type&gt;</a> <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/partition.html">partition</a> (P <span class="keyword">const</span>&amp; p)<span class="keyword"> const </span>{</div>
<div class="line">      <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;tree_type, tree_type&gt;</a> res{detail::partition(impl_, p)};</div>
<div class="line">      <span class="keywordflow">return</span> <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (</div>
<div class="line">       self_type{<a name="a6"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(res.first)}, self_type{<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a> (res.second)});</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Computes a tree with the same keys but where `f` has been</span></div>
<div class="line">    <span class="comment">//applied to all values in the bindings</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> F&gt;</div>
<div class="line">    <span class="keyword">auto</span> map (F f) -&gt; </div>
<div class="line">      binary_search_tree&lt;K, decltype (f (std::declval&lt;V&gt;()))&gt; {</div>
<div class="line">      <span class="keyword">auto</span> l = [=](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; acc, value_type <span class="keyword">const</span>&amp; b) {</div>
<div class="line">        <span class="keywordflow">return</span> acc.insert (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (b.first, f (b.second)));</div>
<div class="line">      };</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;fold (self_type{}, l);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Return the smallest binding (may throw `std::runtime_error` if</span></div>
<div class="line">    <span class="comment">//the tree is empty)</span></div>
<div class="line">    value_type min_binding ()<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> detail::min_binding (impl_);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Return the largest binding (may throw `std::runtime_error` if</span></div>
<div class="line">    <span class="comment">//the tree is empty)</span></div>
<div class="line">    value_type max_binding ()<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> detail::max_binding (impl_);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Factory function for creating a tree from a list</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ItT&gt;</div>
<div class="line">  <span class="keyword">auto</span> mk_tree (ItT <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/begin.html">begin</a>, ItT <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/end.html">end</a>) {</div>
<div class="line">    <span class="keyword">using</span> node_t = <span class="keyword">typename</span> <a name="_a7"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/iterator_traits.html">std::iterator_traits&lt;ItT&gt;::value_type</a>;</div>
<div class="line">    <span class="keyword">using</span> key_t = <span class="keyword">typename</span> node_t::first_type;</div>
<div class="line">    <span class="keyword">using</span> val_t = <span class="keyword">typename</span> node_t::second_type;</div>
<div class="line">    <span class="keyword">using</span> tree_t = binary_search_tree&lt;key_t, val_t&gt;;</div>
<div class="line"></div>
<div class="line">    tree_t l;</div>
<div class="line">    <span class="keywordflow">for</span> (; begin != end; l = l.insert(*begin++));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> l;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}<span class="comment">//namespace&lt;anonymous&gt;</span></div>
<div class="line"></div>
<div class="line">TEST (<a class="code" href="namespacepgs.html">pgs</a>, tree2_basic) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> tree_t = binary_search_tree&lt;int, std::string&gt;;</div>
<div class="line"></div>
<div class="line">  tree_t t;</div>
<div class="line"></div>
<div class="line">  ASSERT_TRUE(t.empty ());</div>
<div class="line"></div>
<div class="line">  tree_t tt = t.insert (</div>
<div class="line">   <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (1, <a name="_a8"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> (<span class="stringliteral">&quot;foo&quot;</span>))).</div>
<div class="line">    insert (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (2, <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> (<span class="stringliteral">&quot;bar&quot;</span>)));</div>
<div class="line"></div>
<div class="line">  ASSERT_EQ(tt.size (), 2);</div>
<div class="line"></div>
<div class="line">  tree_t ttt = tt.remove (2);</div>
<div class="line"></div>
<div class="line">  ASSERT_EQ(ttt.size (), 1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/namespacestd.html">std</a> {<span class="comment">//Hack!</span></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;</div>
<div class="line">  <a name="_a9"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; operator &lt;&lt; (std::ostream&amp; os, std::pair&lt;K, V&gt; <span class="keyword">const</span>&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}<span class="comment">//namspace std</span></div>
<div class="line"></div>
<div class="line">TEST (<a class="code" href="namespacepgs.html">pgs</a>, tree2_more) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> node_t = <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;std::string, int&gt;</a>;</div>
<div class="line">  <span class="keyword">using</span> tree_t = binary_search_tree&lt;std::string, int&gt;;</div>
<div class="line"></div>
<div class="line">  node_t data[] = {</div>
<div class="line">      <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;mike&quot;</span>}, 45),</div>
<div class="line">      <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;sally&quot;</span>}, 25),</div>
<div class="line">      <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;sebastien&quot;</span>}, 33),</div>
<div class="line">      <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;jack&quot;</span>}, 12),</div>
<div class="line">      <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;henry&quot;</span>}, 66)</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  tree_t ages = mk_tree (data, data + 5);</div>
<div class="line"></div>
<div class="line">  EXPECT_EQ (ages.size (), 5);</div>
<div class="line">  EXPECT_TRUE (ages.contains (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;sebastien&quot;</span>}));</div>
<div class="line">  EXPECT_EQ (ages.lookup (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;sally&quot;</span>}), 25);</div>
<div class="line">  EXPECT_THROW (ages.lookup (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> {<span class="stringliteral">&quot;gru&quot;</span>}), <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/error/runtime_error.html">std::runtime_error</a>);</div>
<div class="line"></div>
<div class="line">  <a name="_a10"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Bindings : &quot;</span>;</div>
<div class="line">  ages.bindings (</div>
<div class="line">    <a name="_a11"></a><a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/ostream_iterator.html">std::ostream_iterator</a>&lt;<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;std::string, int&gt;</a>&gt;(std::cout, <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">  );</div>
<div class="line">  std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">auto</span> everyone_of_age = [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; b) { <span class="keywordflow">return</span> b.second &gt; 21; };</div>
<div class="line">  EXPECT_FALSE (ages.for_all (everyone_of_age));</div>
<div class="line">  <span class="keyword">auto</span> no_senior_citizen = [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; b) { <span class="keywordflow">return</span> b.second &lt; 70; };</div>
<div class="line">  EXPECT_TRUE (ages.for_all (no_senior_citizen));</div>
<div class="line">  <span class="keyword">auto</span> sebastien = [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; b) { <span class="keywordflow">return</span> b.first == <span class="stringliteral">&quot;sebastien&quot;</span>; };</div>
<div class="line">  EXPECT_TRUE (ages.exists (sebastien));</div>
<div class="line">  <span class="keyword">auto</span> gru = [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; b) { <span class="keywordflow">return</span> b.first == <span class="stringliteral">&quot;gru&quot;</span>; };</div>
<div class="line">  EXPECT_FALSE (ages.exists (gru));</div>
<div class="line">  <span class="keyword">auto</span> logans_run = ages.filter ([](node_t <span class="keyword">const</span>&amp; b) { <span class="keywordflow">return</span> b.second &gt;= 35; });</div>
<div class="line">  EXPECT_EQ (logans_run.size (), 2);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">auto</span> pp = ages.partition ([](node_t <span class="keyword">const</span>&amp; b) { <span class="keywordflow">return</span> b.second &lt; 30; });</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Those under 30: &quot;</span>;</div>
<div class="line">  pp.first.bindings (</div>
<div class="line">    <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/ostream_iterator.html">std::ostream_iterator</a>&lt;<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;std::string, int&gt;</a>&gt;(std::cout, <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">  );</div>
<div class="line">  std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Those 30 and over: &quot;</span>;</div>
<div class="line">  pp.second.bindings (</div>
<div class="line">    <a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/iterator/ostream_iterator.html">std::ostream_iterator</a>&lt;<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair&lt;std::string, int&gt;</a>&gt;(std::cout, <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">  );</div>
<div class="line">  std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"></div>
<div class="line">  ages = ages.map ([](<span class="keyword">auto</span> age) { <span class="keywordflow">return</span> ++age; });</div>
<div class="line">  EXPECT_EQ(ages.lookup (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>{<span class="stringliteral">&quot;henry&quot;</span>}), 67);</div>
<div class="line"></div>
<div class="line">  EXPECT_EQ (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>{<span class="stringliteral">&quot;henry&quot;</span>}, 67), ages.min_binding ());</div>
<div class="line">  EXPECT_EQ (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair</a> (<a class="codeRef" doxygen="D:/project/pretty-good-sum.git/doxygen/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>{<span class="stringliteral">&quot;sebastien&quot;</span>}, 34), ages.max_binding ());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
